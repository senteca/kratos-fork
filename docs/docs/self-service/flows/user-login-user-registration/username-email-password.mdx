---
id: username-email-password
title: Username or Email and Password
---

:::tip Before you start

Please read the
[Username / Email & Password Credentials Documentation](../../../concepts/credentials/username-email-password.mdx)
and
[User Login and Registration Documentation](../user-login-user-registration.mdx)
and [Self-Service Flows Documentation](../../../self-service) first.

:::

import CodeFromRemote from '@theme/CodeFromRemote'

This document summarizes exemplary request payloads for performing "login or
sign up with email/username and password" flows using the user login and
registration flow with the `password` method.

We will use the following JSON Schema in all examples on this page:

<CodeFromRemote
  link="https://github.com/ory/kratos/blob/master/contrib/quickstart/kratos/email-password/identity.traits.schema.json"
  src="https://raw.githubusercontent.com/ory/kratos/master/contrib/quickstart/kratos/email-password/identity.traits.schema.json"
/>

## Browser Clients

Browser clients are server-side applications that run in a browser, or Single
Page Apps (ReactJS, AngularJS, ...).

### Registration

Redirecting the browser to the
[Self-Service Login and Registration Endpoint](../user-login-user-registration.mdx#user-login-and-user-registration-process-sequence)
initiates the flow. If the `password` method is enabled, the Registration
Request Response Payload will include a `password` method.

ORY Kratos uses the Identity JSON Schema defined in
`identity.default_schema_url` to generate a list of form fields and add it to
the Registration Request.

The identity schema above will result in the following Registration Request

```shell script
$ curl -H "Accept: application/json" -s \
    'http://127.0.0.1:4434/self-service/registration/flows?id=d5c78fd6-17e7-45e2-9465-0200c76bf83a' | jq

{
  "id": "d5c78fd6-17e7-45e2-9465-0200c76bf83a",
  "type": "browser",
  "expires_at": "2020-08-24T11:58:06.0780652Z",
  "issued_at": "2020-08-24T11:48:06.0780828Z",
  "request_url": "http://127.0.0.1:4433/self-service/registration/browser",
  "messages": null,
  "methods": {
    "password": {
      "method": "password",
      "config": {
        "action": "http://127.0.0.1:4433/self-service/registration/methods/password?flow=d5c78fd6-17e7-45e2-9465-0200c76bf83a",
        "method": "POST",
        "fields": [
          {
            "name": "csrf_token",
            "type": "hidden",
            "required": true,
            "value": "NeScRZ0rccVGilfS2dvlSjDnYk/EvhpozPKW3TBeAnpCArwCFt2La1xbxeFFnmFycdg1LngGTeA13HJ1XCccQA=="
          },
          {
            "name": "password",
            "type": "password",
            "required": true
          },
          {
            "name": "traits.email",
            "type": "email"
          },
          {
            "name": "traits.name.first",
            "type": "text"
          },
          {
            "name": "traits.name.last",
            "type": "text"
          }
        ]
      }
    }
  }
}
```

which in turn is easily to render by filling out a HTML Form template:

```html
<form method="{{ method }}" action="{{ action }}">
  <!-- repeat this for every field -->
  <input type="{{ field.type }}" name="{{ field.name }} required="{{
  field.required }}" value="{{ field.value }}"
  <!-- ... -->>

  <input type="submit" value="Create account" />
</form>
```

Once the user clicks "Create Account", the payload will be sent to ORY Kratos'
Public API. The data will be validated against the Identity JSON Schema (e.g.
checking if a required field is missing, if some condition like `minLength` is
not fulfilled, ...). If the data is invalid or incomplete, the browser will be
redirected to the same login endpoint with the same request ID. When fetching
that request ID again, error details will be included in the JSON Response, such
as:

```shell script
$ curl -H "Accept: application/json" -s \
    'http://127.0.0.1:4434/self-service/registration/flows?id=d5c78fd6-17e7-45e2-9465-0200c76bf83a' | jq

{
  "id": "d5c78fd6-17e7-45e2-9465-0200c76bf83a",
  "type": "browser",
  "expires_at": "2020-08-24T11:58:06.0780652Z",
  "issued_at": "2020-08-24T11:48:06.0780828Z",
  "request_url": "http://127.0.0.1:4433/self-service/registration/browser",
  "active": "password",
  "messages": null,
  "methods": {
    "password": {
      "method": "password",
      "config": {
        "action": "http://127.0.0.1:4433/self-service/registration/methods/password?flow=d5c78fd6-17e7-45e2-9465-0200c76bf83a",
        "method": "POST",
        "fields": [
          {
            "name": "csrf_token",
            "type": "hidden",
            "required": true,
            "value": "9ffVGnARIis5qPaS8JGoaNLHgxODXlkDq00GE+XK+fGCEfVd++fYhSN5ZKFs1CxQk/jUcj/mDotSY+K7ibPnyw=="
          },
          {
            "name": "password",
            "type": "password",
            "required": true,
            "messages": [
              {
                "id": 4000002,
                "text": "Property password is missing.",
                "type": "error",
                "context": {
                  "property": "password"
                }
              }
            ]
          },
          {
            "name": "traits.email",
            "type": "text",
            "value": ""
          },
          {
            "name": "traits.name.first",
            "type": "text",
            "value": ""
          },
          {
            "name": "traits.name.last",
            "type": "text",
            "value": ""
          }
        ]
      }
    }
  }
}
```

If the form is valid, ORY Kratos will create the user and respond with a HTTP
302 redirect to the configured redirect URL.

Unless the `session` hook is configured, no session cookie will be included in
the `Set-Cookie` HTTP header.

### Login

Redirecting the browser to the
[Self-Service Login and Registration Endpoint](../user-login-user-registration.mdx#user-login-and-user-registration-process-sequence)
initiates the flow. If the `password` method is enabled, the Login Request
Response Payload will include a `password` method. In contrast to the
Registration sequence, this payload does not change when the Identity JSON
Schema changes:

```shell script
$ curl -H "Accept: application/json" -s \
    'http://127.0.0.1:4434/self-service/login/flows?id=7c4260f5-55ad-470a-b1d4-e72dd011e4fe' | jq

{
  "id": "7c4260f5-55ad-470a-b1d4-e72dd011e4fe",
  "type": "browser",
  "expires_at": "2020-08-24T12:01:46.0750749Z",
  "issued_at": "2020-08-24T11:51:46.0750749Z",
  "request_url": "http://127.0.0.1:4433/self-service/login/browser",
  "messages": null,
  "methods": {
    "password": {
      "method": "password",
      "config": {
        "action": "http://127.0.0.1:4433/self-service/login/methods/password?flow=7c4260f5-55ad-470a-b1d4-e72dd011e4fe",
        "method": "POST",
        "fields": [
          {
            "name": "identifier",
            "type": "text",
            "required": true,
            "value": ""
          },
          {
            "name": "password",
            "type": "password",
            "required": true
          },
          {
            "name": "csrf_token",
            "type": "hidden",
            "required": true,
            "value": "IwmnH/orHuk6WW5vQ775zcPj01vRFva/rgdIQG4A7G5U74dYcd3kRyCI/Fzf+331gtyEOm2uoTdXKazoAnnyVA=="
          }
        ]
      }
    }
  },
  "forced": false
}
```

If the login form is filled out incorrectly, errors are included in the
response:

```shell script
$ curl -H "Accept: application/json" -s \
    'http://127.0.0.1:4434/self-service/login/flows?id=7c4260f5-55ad-470a-b1d4-e72dd011e4fe' | jq

{
  "id": "7c4260f5-55ad-470a-b1d4-e72dd011e4fe",
  "type": "browser",
  "expires_at": "2020-08-24T12:01:46.0750749Z",
  "issued_at": "2020-08-24T11:51:46.0750749Z",
  "request_url": "http://127.0.0.1:4433/self-service/login/browser",
  "active": "password",
  "messages": null,
  "methods": {
    "password": {
      "method": "password",
      "config": {
        "action": "http://127.0.0.1:4433/self-service/login/methods/password?flow=7c4260f5-55ad-470a-b1d4-e72dd011e4fe",
        "method": "POST",
        "fields": [
          {
            "name": "identifier",
            "type": "text",
            "required": true,
            "value": "i-do-not-exist@exist.org"
          },
          {
            "name": "password",
            "type": "password",
            "required": true
          },
          {
            "name": "csrf_token",
            "type": "hidden",
            "required": true,
            "value": "t41eXWhSYPsObQv8gqk8KHPkUt5ItrQj9vMRYLVWACfAa34a46SaVRS8mc8e7LgQMtsFv/QO46sP3fXI2S8eHQ=="
          }
        ],
        "messages": [
          {
            "id": 4000006,
            "text": "The provided credentials are invalid, check for spelling mistakes in your password or username, email address, or phone number.",
            "type": "error",
            "context": {}
          }
        ]
      }
    }
  },
  "forced": false
}
```

If the form is valid (the user exists and the password is correct), ORY Kratos
will respond with a HTTP 302 redirect to the configured redirect URL and set a
session cookie using the `Set-Cookie` HTTP Header.

## API Clients

API clients are applications which do not run in a browser or in a URL (e.g.
`https://my-example.org`). These are typically native apps (e.g. iOS, Android).

### Registration

The registration is initiated by making a request to the Registration API Flow
Initialization endpoint:

```shell script
$ curl -H "Accept: application/json" -s \
    'http://127.0.0.1:4433/self-service/registration/api' | jq

{
  "id": "56b5018a-6c47-4675-8ce8-2f463ac77fcb",
  "type": "api",
  "expires_at": "2020-08-24T12:11:40.5897696Z",
  "issued_at": "2020-08-24T12:01:40.5897865Z",
  "request_url": "http://127.0.0.1:4433/self-service/registration/api",
  "messages": null,
  "methods": {
    "password": {
      "method": "password",
      "config": {
        "action": "http://127.0.0.1:4433/self-service/registration/methods/password?flow=56b5018a-6c47-4675-8ce8-2f463ac77fcb",
        "method": "POST",
        "fields": [
          {
            "name": "csrf_token",
            "type": "hidden",
            "required": true,
            "value": "4wcp5isuhvN5Ulwqe0p1bZapLP9iP5JYkcrVzmPs6pQzhVtEC66LOXKYppMqXr2PfZDYcPaU17neuXHpQwWatQ=="
          },
          {
            "name": "password",
            "type": "password",
            "required": true
          },
          {
            "name": "traits.email",
            "type": "email"
          },
          {
            "name": "traits.name.first",
            "type": "text"
          },
          {
            "name": "traits.name.last",
            "type": "text"
          }
        ]
      }
    }
  }
}
```

As you can see, the flow content is very similar to the one for browser flows.
The only difference is that `type` is now `api` and not `browser`.

This payload then renders that payload as a native form. The implementation
depends on the language, platform, and framework you use.

To submit the form, the client makes a request to the action URL which results
in an error here because the password does not match the password policy:

```shell script
# e.g. http://127.0.0.1:4433/self-service/registration/methods/password?flow=d6e0dd24-f5c6-4926-a526-616a9afeed9d
actionUrl=$(echo $(curl -s -X GET -H "Accept: application/json" "http://127.0.0.1:4433/self-service/registration/api") \
  | jq -r '.methods.password.config.action')

curl -s -X POST -H  "Accept: application/json" -H "Content-Type: application/json" \
    -d '{"traits.email": "api@user.org", "password": "123456", "traits.name.first": "API", "traits.name.last": "User"}' \
    "$actionUrl" | jq
{
  "id": "f7e4dfeb-20b1-466a-8cdc-8575070e3c55",
  "type": "api",
  "expires_at": "2020-08-24T13:44:25.3643328Z",
  "issued_at": "2020-08-24T13:34:25.3643495Z",
  "request_url": "http://127.0.0.1:4433/self-service/registration/api",
  "active": "password",
  "messages": null,
  "methods": {
    "password": {
      "method": "password",
      "config": {
        "action": "http://127.0.0.1:4433/self-service/registration/methods/password?flow=f7e4dfeb-20b1-466a-8cdc-8575070e3c55",
        "method": "POST",
        "fields": [
          {
            "name": "csrf_token",
            "type": "hidden",
            "required": true,
            "value": "pUShn2vN9kHtQYIYQylabkbCUcRkHAR6R3jeQyzpaAd1RTIFu6NlyTVDQRmMDc6RW+RMq/sCuV4XU1zzKmiqRA=="
          },
          {
            "name": "password",
            "type": "password",
            "required": true,
            "messages": [
              {
                "id": 4000005,
                "text": "The password can not be used because the password has been found in at least 23597311 data breaches and must no longer be used..",
                "type": "error",
                "context": {
                  "reason": "the password has been found in at least 23597311 data breaches and must no longer be used."
                }
              }
            ]
          },
          {
            "name": "traits.email",
            "type": "text",
            "value": "api@user.org"
          },
          {
            "name": "traits.name.first",
            "type": "text",
            "value": "API"
          },
          {
            "name": "traits.name.last",
            "type": "text",
            "value": "User"
          }
        ]
      }
    }
  }
}
```

A successful registration payload results in:

```shell script
actionUrl=$(echo $(curl -s -X GET -H "Accept: application/json" "http://127.0.0.1:4433/self-service/registration/api") \
  | jq -r '.methods.password.config.action')

curl -s -X POST -H  "Accept: application/json" -H "Content-Type: application/json" \
    -d '{"traits.email": "api@user.org", "password": "iohuasf0897zAJHf", "traits.name.first": "API", "traits.name.last": "User"}' \
    "$actionUrl" | jq
{
  "identity": {
    "id": "bf32596a-f853-47c4-91e6-a3f41cf4949d",
    "schema_id": "default",
    "schema_url": "http://127.0.0.1:4433/schemas/default",
    "traits": {
      "email": "api@user.org",
      "name": {
        "last": "User",
        "first": "API"
      }
    },
    "verifiable_addresses": [
      {
        "id": "f877db6c-7dfb-45e3-bbeb-ac8349348128",
        "value": "api@user.org",
        "verified": false,
        "via": "email",
        "verified_at": null,
        "expires_at": "2020-08-24T14:35:59.125873Z"
      }
    ],
    "recovery_addresses": [
      {
        "id": "065a908c-82be-4110-bf67-9910f36242b7",
        "value": "api@user.org",
        "via": "email"
      }
    ]
  }
}
```

If the `session` hook is configured, you will also receive a session and a
session token:

```json
{
  "identity": {
    "id": "bf32596a-f853-47c4-91e6-a3f41cf4949d",
    "schema_id": "default",
    "schema_url": "http://127.0.0.1:4433/schemas/default",
    "traits": {
      "email": "api@user.org",
      "name": {
        "last": "User",
        "first": "API"
      }
    },
    "verifiable_addresses": [
      {
        "id": "f877db6c-7dfb-45e3-bbeb-ac8349348128",
        "value": "api@user.org",
        "verified": false,
        "via": "email",
        "verified_at": null,
        "expires_at": "2020-08-24T14:35:59.125873Z"
      }
    ],
    "recovery_addresses": [
      {
        "id": "065a908c-82be-4110-bf67-9910f36242b7",
        "value": "api@user.org",
        "via": "email"
      }
    ]
  },
  "session_token": "l98BYBlbE9GYeERnysrSY88YSaZSypQP",
  "session": {
    "id": "2d754296-ed43-49d0-838d-f268800f109c",
    "active": true,
    "expires_at": "2020-08-25T13:35:59.1250534Z",
    "authenticated_at": "2020-08-24T13:35:59.1336419Z",
    "issued_at": "2020-08-24T13:35:59.1250772Z",
    "identity": {
      "id": "bf32596a-f853-47c4-91e6-a3f41cf4949d",
      "schema_id": "default",
      "schema_url": "http://127.0.0.1:4433/schemas/default",
      "traits": {
        "email": "api@user.org",
        "name": {
          "last": "User",
          "first": "API"
        }
      },
      "verifiable_addresses": [
        {
          "id": "f877db6c-7dfb-45e3-bbeb-ac8349348128",
          "value": "api@user.org",
          "verified": false,
          "via": "email",
          "verified_at": null,
          "expires_at": "2020-08-24T14:35:59.125873Z"
        }
      ],
      "recovery_addresses": [
        {
          "id": "065a908c-82be-4110-bf67-9910f36242b7",
          "value": "api@user.org",
          "via": "email"
        }
      ]
    }
  }
}
```

### Login

The login is initiated by making a request to the Login API Flow Initialization
endpoint:

```shell script
$ curl -H "Accept: application/json" -s \
    'http://127.0.0.1:4433/self-service/login/api' | jq

{
  "id": "2cf23130-9164-44be-8fe8-badade883f24",
  "type": "api",
  "expires_at": "2020-08-24T12:04:15.2332125Z",
  "issued_at": "2020-08-24T11:54:15.2332125Z",
  "request_url": "http://127.0.0.1:4433/self-service/login/api",
  "messages": null,
  "methods": {
    "password": {
      "method": "password",
      "config": {
        "action": "http://127.0.0.1:4433/self-service/login/methods/password?flow=2cf23130-9164-44be-8fe8-badade883f24",
        "method": "POST",
        "fields": [
          {
            "name": "identifier",
            "type": "text",
            "required": true,
            "value": ""
          },
          {
            "name": "password",
            "type": "password",
            "required": true
          },
          {
            "name": "csrf_token",
            "type": "hidden",
            "required": true,
            "value": "OoFnnSXYUjRqbuPvRay7pafxkLPExzmL68Eg15EMxdQbTRyL1s6FUlLgz8VzcAcUVjd7x7EJgjA6koUAn+4kSg=="
          }
        ]
      }
    }
  },
  "forced": false
}
```

As you can see, the flow content is very similar to the one for browser flows.
The only difference is that `type` is now `api` and not `browser`.

This payload then renders that payload as a native form. The implementation
depends on the language, platform, and framework you use.

To submit the form, the client makes a request to the action URL which results
in an error here because the user is unknown:

```shell script
# e.g. http://127.0.0.1:4433/self-service/login/methods/password?flow=d6e0dd24-f5c6-4926-a526-616a9afeed9d
actionUrl=$(echo $(curl -s -X GET -H "Accept: application/json" "http://127.0.0.1:4433/self-service/login/api") \
  | jq -r '.methods.password.config.action')

curl -s -X POST -H  "Accept: application/json" -H "Content-Type: application/json" \
    -d '{"identifier": "i-do-not-exist@user.org", "password": "the-wrong-password"}' \
    "$actionUrl" | jq

{
  "id": "37703ca6-bf0a-497d-aead-ce573ab67eb6",
  "type": "api",
  "expires_at": "2020-08-24T12:08:18.4591524Z",
  "issued_at": "2020-08-24T11:58:18.4591524Z",
  "request_url": "http://127.0.0.1:4433/self-service/login/api",
  "active": "password",
  "messages": null,
  "methods": {
    "password": {
      "method": "password",
      "config": {
        "action": "http://127.0.0.1:4433/self-service/login/methods/password?flow=37703ca6-bf0a-497d-aead-ce573ab67eb6",
        "method": "POST",
        "fields": [
          {
            "name": "identifier",
            "type": "text",
            "required": true,
            "value": "i-do-not-exist@user.org"
          },
          {
            "name": "password",
            "type": "password",
            "required": true
          },
          {
            "name": "csrf_token",
            "type": "hidden",
            "required": true
          }
        ],
        "messages": [
          {
            "id": 4000006,
            "text": "The provided credentials are invalid, check for spelling mistakes in your password or username, email address, or phone number.",
            "type": "error",
            "context": {}
          }
        ]
      }
    }
  },
  "forced": false
}
```

If user and password are correct, the server responds with a session token and a
session:

```shell script
# e.g. http://127.0.0.1:4433/self-service/login/methods/password?flow=d6e0dd24-f5c6-4926-a526-616a9afeed9d
actionUrl=$(echo $(curl -s -X GET -H "Accept: application/json" "http://127.0.0.1:4433/self-service/login/api") \
  | jq -r '.methods.password.config.action')

curl -s -X POST -H  "Accept: application/json" -H "Content-Type: application/json" \
    -d '{"identifier": "api@user.org", "password": "iohuasf0897zAJHf"}' \
    "$actionUrl" | jq

{
  "session_token": "oFZzgLpsacUpUy2cvQPtrGa2046WcXCR",
  "session": {
    "id": "8f660ce3-69ec-4aeb-9fda-f9230dc3243f",
    "active": true,
    "expires_at": "2020-08-25T13:42:15.7411522Z",
    "authenticated_at": "2020-08-24T13:42:15.7411522Z",
    "issued_at": "2020-08-24T13:42:15.7412042Z",
    "identity": {
      "id": "bf32596a-f853-47c4-91e6-a3f41cf4949d",
      "schema_id": "default",
      "schema_url": "http://127.0.0.1:4433/schemas/default",
      "traits": {
        "email": "api@user.org",
        "name": {
          "last": "User",
          "first": "API"
        }
      },
      "verifiable_addresses": [
        {
          "id": "f877db6c-7dfb-45e3-bbeb-ac8349348128",
          "value": "api@user.org",
          "verified": false,
          "via": "email",
          "verified_at": null,
          "expires_at": "2020-08-24T14:35:59.125873Z"
        }
      ],
      "recovery_addresses": [
        {
          "id": "065a908c-82be-4110-bf67-9910f36242b7",
          "value": "api@user.org",
          "via": "email"
        }
      ]
    }
  }
}
```

## Security and Defenses

Password-based authentication flows are subject to frequent abuse through

- Social Engineering Attacks;
- Password Guessing Attacks;
- Phishing Attacks.

### Anti-automation

> This feature is a work in progress and is tracked as
> [kratos#133](https://github.com/ory/kratos/issues/138).

Actions that cause out-of-band communications, such as sending an activation
link via email or an activation code via SMS, can be abused by automated
systems. The goal of such an attack is to send out so many emails or SMS, that
your reputation worsens (spam filters) or you're faced with massive costs
(carrier fees).

CAPTCHA renders these attacks either very difficult or impossible. ORY Kratos
has CAPTCHA support built-in. ORY Kratos will prompt the user to complete a
CAPTCHA in the following scenarios:

- The user tries to register more than one account within 72 hours.
- The user failed provide valid credentials for the third time within 12 hours.
- The user tries to recover their account for the second time within 72 hours.

For integration guidelines, please check the individual flow's (registration,
login, account recovery) integration documentation.

### Account Takeover Defenses

The Settings flow implements account takeover defenses as it is not possible to
change the password without knowing the existing password. A good example of
this flow is the
[GitHub sudo mode](https://help.github.com/en/github/authenticating-to-github/sudo-mode).

### Password Validation

> Further improvements are work in progress and are tracked on
> [GitHub](https://github.com/ory/kratos/issues?q=is%3Aopen+label%3Amodule%3Ass%2Fpassword+)

To prevent weak passwords ORY Kratos implements different measures. Users often
choose passwords similar to their traits. To prevent this ORY Kratos ensures
there is a sufficient
[Levenshtein-Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) (aka
"Edit-Distance") between the identifier and the password. It also makes sure
that the identifier and password have a small enough longest common substring.

Furthermore the `password` method comes with a build-in check against the
["Have I been pwned"](https://haveibeenpwned.com) breach database. This way ORY
Kratos makes sure your users cannot use passwords like "password", "123456" or
any other commonly used one. To protect the value of the password the
[range API](https://haveibeenpwned.com/API/v3#SearchingPwnedPasswordsByRange) is
being used.

### Account Enumeration Defenses (work in progress)

:::warning

This feature is a work in progress and is tracked as
[kratos#133](https://github.com/ory/kratos/issues/133).

It does not yet work as documented!

:::

Account enumeration attacks allow a attacker to find out who is signed up. This
compromises the privacy of your users and can hurt reputation depending on the
service (e.g. "adult content").

This attack usually makes only sense if an email address or a phone number is
collected during registration. For chosen usernames, this attack is much more
difficult, as the attacker has to know what usernames the victim is using.

There are three common ways an attacker can figure out if a user is signed up at
a service:

- During login: "No user with this email address was found"
- During registration: "A user with this email address exists already"
- During password reset: "No user with this email address was found"

To mitigate this attack, the following methods need to be deployed:

- The login form should return the same message regardless of whether the
  password is wrong or the email/username does not exist: "The provided
  credentials are invalid."
- The password reset form should always return a success message and send out an
  email. If the email address is registered, a normal password reset email is
  sent. If the email address is not registered, an email is sent to the address
  indicating that no account is set up with that email address. This is helpful
  to users that have multiple email addresses and are using the wrong email
  address for the password reset.
- The registration form should also always return a success message and send out
  an email. If the email address is not yet registered, a regular "account
  activation" email is sent out. If the email address is registered already, a
  email is sent out telling the user that the account is already set up, and
  link to the login screen.

If you wish to mitigate account enumeration attacks, it is important to note
that you cannot sign in users directly after sign up! Depending on the type of
service you provide, you might not care about this specific attack in which case
direct login after sign up would be ok.

#### Enabling Account Enumeration Defenses

Assuming you wish to enable account enumeration defenses, you need to configure
ORY Kratos as follows:

- Collect one or more email addresses during sign up and enable email
  verification.
- **Do not** enable the `session` post-registration workflow.

```yaml
selfservice:
  flows:
    verification:
      enabled: true
```

#### Disable Account Enumeration Defenses

Enforcing email verification, which requires an email round trip and disrupts
the sign up process, is not always feasible. In these cases, you might want to
disable account enumeration defenses.

You can disable the defense mechanism on a per-field basis in your Identity JSON
Schema:

```json title="path/to/my/identity.schema.json"
{
  "$id": "https://example.com/identity.traits.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Person",
  "type": "object",
  "properties": {
    "traits": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "ory.sh/kratos": {
            "credentials": {
              "password": {
                "identifier": true,
                "disable_account_enumeration_defenses": true
              }
            }
          }
        }
      }
    }
  }
}
```

This will tell ORY Kratos to display messages such as "a user with this email
address exists already" and "no user with this email address is registered on
this site". You can then enable the `session` post-registration workflow:

```yaml
selfservice:
  flows:
    registration:
      after:
        password:
          - hook: session
```
