---
title: REST API
id: api
---



Welcome to the ORY Kratos HTTP API documentation!

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

:::info

You are viewing REST API documentation. This documentation is auto-generated from a swagger specification which
itself is generated from annotations in the source code of the project. It is possible that this documentation includes
bugs and that code samples are incomplete or wrong.

If you find issues in the respective documentation, please do not edit the
Markdown files directly (as they are generated) but raise an issue on the project's GitHub presence instead. This documentation
will improve over time with your help! If you have ideas how to improve this part of the documentation, feel free to
share them in a [GitHub issue](https://github.com/ory/docs/issues/new) any time.

:::

<a id="ory-kratos-health"></a>

## health

<a id="opIdisInstanceAlive"></a>

### Check alive status

```
GET /health/alive HTTP/1.1
Accept: application/json

```

This endpoint returns a 200 status code when the HTTP server is up running.
This status does currently not include checks whether the database connection is working.

If the service supports TLS Edge Termination, this endpoint does not require the
`X-Forwarded-Proto` header to be set.

Be aware that if you are running multiple nodes of this service, the health status will never
refer to the cluster state, only to a single instance.

#### Responses

<a id="check-alive-status-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|healthStatus|[healthStatus](#schemahealthstatus)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "status": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /health/alive \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/health/alive", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/health/alive', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/health/alive");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/health/alive',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/health/alive',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdisInstanceReady"></a>

### Check readiness status

```
GET /health/ready HTTP/1.1
Accept: application/json

```

This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g.
the database) are responsive as well.

If the service supports TLS Edge Termination, this endpoint does not require the
`X-Forwarded-Proto` header to be set.

Be aware that if you are running multiple nodes of this service, the health status will never
refer to the cluster state, only to a single instance.

#### Responses

<a id="check-readiness-status-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|healthStatus|[healthStatus](#schemahealthstatus)|
|503|[Service Unavailable](https://tools.ietf.org/html/rfc7231#section-6.6.4)|healthNotReadyStatus|[healthNotReadyStatus](#schemahealthnotreadystatus)|

##### Examples

###### 200 response

```json
{
  "status": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /health/ready \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/health/ready", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/health/ready', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/health/ready");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/health/ready',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/health/ready',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="ory-kratos-administrative-endpoints"></a>

## Administrative Endpoints

<a id="opIdlistIdentities"></a>

### List all identities in the system

```
GET /identities HTTP/1.1
Accept: application/json

```

This endpoint returns a login request's context with, for example, error details and
other information.

Learn how identities work in [ORY Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).

#### Responses

<a id="list-all-identities-in-the-system-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A list of identities.|Inline|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

<a id="list-all-identities-in-the-system-responseschema"></a>
##### Response Schema

Status Code **200**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|[[Identity](#schemaidentity)]|false|none|none|
|» id|[UUID](#schemauuid)(uuid4)|true|none|none|
|» recovery_addresses|[[RecoveryAddress](#schemarecoveryaddress)]|false|none|RecoveryAddresses contains all the addresses that can be used to recover an identity.|
|»» id|[UUID](#schemauuid)(uuid4)|true|none|none|
|»» value|string|true|none|none|
|»» via|[RecoveryAddressType](#schemarecoveryaddresstype)|true|none|none|
|» schema_id|string|true|none|SchemaID is the ID of the JSON Schema to be used for validating the identity's traits.|
|» schema_url|string|false|none|SchemaURL is the URL of the endpoint where the identity's traits schema can be fetched from.  format: url|
|» traits|[Traits](#schematraits)|true|none|none|
|» verifiable_addresses|[[VerifiableAddress](#schemaverifiableaddress)]|false|none|VerifiableAddresses contains all the addresses that can be verified by the user.|
|»» expires_at|string(date-time)|true|none|none|
|»» id|[UUID](#schemauuid)(uuid4)|true|none|none|
|»» value|string|true|none|none|
|»» verified|boolean|true|none|none|
|»» verified_at|string(date-time)|false|none|none|
|»» via|[VerifiableAddressType](#schemaverifiableaddresstype)|true|none|none|

##### Examples

###### 200 response

```json
[
  {
    "id": "string",
    "recovery_addresses": [
      {
        "id": "string",
        "value": "string",
        "via": "string"
      }
    ],
    "schema_id": "string",
    "schema_url": "string",
    "traits": {},
    "verifiable_addresses": [
      {
        "expires_at": "2019-08-24T14:15:22Z",
        "id": "string",
        "value": "string",
        "verified": true,
        "verified_at": "2019-08-24T14:15:22Z",
        "via": "string"
      }
    ]
  }
]
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /identities \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/identities", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/identities', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/identities");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/identities',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/identities',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdcreateIdentity"></a>

### Create an identity

```
POST /identities HTTP/1.1
Content-Type: application/json
Accept: application/json

```

This endpoint creates an identity. It is NOT possible to set an identity's credentials (password, ...)
using this method! A way to achieve that will be introduced in the future.

Learn how identities work in [ORY Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).

#### Request body

```json
{
  "id": "string",
  "recovery_addresses": [
    {
      "id": "string",
      "value": "string",
      "via": "string"
    }
  ],
  "schema_id": "string",
  "schema_url": "string",
  "traits": {},
  "verifiable_addresses": [
    {
      "expires_at": "2019-08-24T14:15:22Z",
      "id": "string",
      "value": "string",
      "verified": true,
      "verified_at": "2019-08-24T14:15:22Z",
      "via": "string"
    }
  ]
}
```

<a id="create-an-identity-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[Identity](#schemaidentity)|true|none|

#### Responses

<a id="create-an-identity-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|201|[Created](https://tools.ietf.org/html/rfc7231#section-6.3.2)|A single identity.|[Identity](#schemaidentity)|
|400|[Bad Request](https://tools.ietf.org/html/rfc7231#section-6.5.1)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 201 response

```json
{
  "id": "string",
  "recovery_addresses": [
    {
      "id": "string",
      "value": "string",
      "via": "string"
    }
  ],
  "schema_id": "string",
  "schema_url": "string",
  "traits": {},
  "verifiable_addresses": [
    {
      "expires_at": "2019-08-24T14:15:22Z",
      "id": "string",
      "value": "string",
      "verified": true,
      "verified_at": "2019-08-24T14:15:22Z",
      "via": "string"
    }
  ]
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X POST /identities \
  -H 'Content-Type: application/json' \  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("POST", "/identities", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');
const input = '{
  "id": "string",
  "recovery_addresses": [
    {
      "id": "string",
      "value": "string",
      "via": "string"
    }
  ],
  "schema_id": "string",
  "schema_url": "string",
  "traits": {},
  "verifiable_addresses": [
    {
      "expires_at": "2019-08-24T14:15:22Z",
      "id": "string",
      "value": "string",
      "verified": true,
      "verified_at": "2019-08-24T14:15:22Z",
      "via": "string"
    }
  ]
}';
const headers = {
  'Content-Type': 'application/json',  'Accept': 'application/json'
}

fetch('/identities', {
  method: 'POST',
  body: input,
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/identities");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("POST");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.post(
  '/identities',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.post '/identities',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdgetIdentity"></a>

### Get an identity

```
GET /identities/{id} HTTP/1.1
Accept: application/json

```

Learn how identities work in [ORY Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).

<a id="get-an-identity-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|string|true|ID must be set to the ID of identity you want to get|

#### Responses

<a id="get-an-identity-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A single identity.|[Identity](#schemaidentity)|
|400|[Bad Request](https://tools.ietf.org/html/rfc7231#section-6.5.1)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "id": "string",
  "recovery_addresses": [
    {
      "id": "string",
      "value": "string",
      "via": "string"
    }
  ],
  "schema_id": "string",
  "schema_url": "string",
  "traits": {},
  "verifiable_addresses": [
    {
      "expires_at": "2019-08-24T14:15:22Z",
      "id": "string",
      "value": "string",
      "verified": true,
      "verified_at": "2019-08-24T14:15:22Z",
      "via": "string"
    }
  ]
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /identities/{id} \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/identities/{id}", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/identities/{id}', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/identities/{id}");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/identities/{id}',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/identities/{id}',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdupdateIdentity"></a>

### Update an identity

```
PUT /identities/{id} HTTP/1.1
Content-Type: application/json
Accept: application/json

```

This endpoint updates an identity. It is NOT possible to set an identity's credentials (password, ...)
using this method! A way to achieve that will be introduced in the future.

The full identity payload (except credentials) is expected. This endpoint does not support patching.

Learn how identities work in [ORY Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).

#### Request body

```json
{
  "id": "string",
  "recovery_addresses": [
    {
      "id": "string",
      "value": "string",
      "via": "string"
    }
  ],
  "schema_id": "string",
  "schema_url": "string",
  "traits": {},
  "verifiable_addresses": [
    {
      "expires_at": "2019-08-24T14:15:22Z",
      "id": "string",
      "value": "string",
      "verified": true,
      "verified_at": "2019-08-24T14:15:22Z",
      "via": "string"
    }
  ]
}
```

<a id="update-an-identity-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|string|true|ID must be set to the ID of identity you want to update|
|body|body|[Identity](#schemaidentity)|true|none|

#### Responses

<a id="update-an-identity-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A single identity.|[Identity](#schemaidentity)|
|400|[Bad Request](https://tools.ietf.org/html/rfc7231#section-6.5.1)|genericError|[genericError](#schemagenericerror)|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "id": "string",
  "recovery_addresses": [
    {
      "id": "string",
      "value": "string",
      "via": "string"
    }
  ],
  "schema_id": "string",
  "schema_url": "string",
  "traits": {},
  "verifiable_addresses": [
    {
      "expires_at": "2019-08-24T14:15:22Z",
      "id": "string",
      "value": "string",
      "verified": true,
      "verified_at": "2019-08-24T14:15:22Z",
      "via": "string"
    }
  ]
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X PUT /identities/{id} \
  -H 'Content-Type: application/json' \  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("PUT", "/identities/{id}", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');
const input = '{
  "id": "string",
  "recovery_addresses": [
    {
      "id": "string",
      "value": "string",
      "via": "string"
    }
  ],
  "schema_id": "string",
  "schema_url": "string",
  "traits": {},
  "verifiable_addresses": [
    {
      "expires_at": "2019-08-24T14:15:22Z",
      "id": "string",
      "value": "string",
      "verified": true,
      "verified_at": "2019-08-24T14:15:22Z",
      "via": "string"
    }
  ]
}';
const headers = {
  'Content-Type': 'application/json',  'Accept': 'application/json'
}

fetch('/identities/{id}', {
  method: 'PUT',
  body: input,
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/identities/{id}");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("PUT");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.put(
  '/identities/{id}',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.put '/identities/{id}',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIddeleteIdentity"></a>

### Delete an identity

```
DELETE /identities/{id} HTTP/1.1
Accept: application/json

```

This endpoint deletes an identity. This can not be undone.

Learn how identities work in [ORY Kratos' User And Identity Model Documentation](https://www.ory.sh/docs/next/kratos/concepts/identity-user-model).

<a id="delete-an-identity-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|string|true|ID is the identity's ID.|

#### Responses

<a id="delete-an-identity-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|204|[No Content](https://tools.ietf.org/html/rfc7231#section-6.3.5)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 404 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X DELETE /identities/{id} \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("DELETE", "/identities/{id}", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/identities/{id}', {
  method: 'DELETE',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/identities/{id}");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("DELETE");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.delete(
  '/identities/{id}',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.delete '/identities/{id}',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="ory-kratos-common"></a>

## common

<a id="opIdgetSchema"></a>

### getSchema

```
GET /schemas/{id} HTTP/1.1
Accept: application/json

```

Get a traits schema definition

<a id="getschema-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|string|true|ID must be set to the ID of schema you want to get|

#### Responses

<a id="getschema-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|The raw identity traits schema|Inline|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

<a id="getschema-responseschema"></a>
##### Response Schema

##### Examples

###### 200 response

```json
{}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /schemas/{id} \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/schemas/{id}", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/schemas/{id}', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/schemas/{id}");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/schemas/{id}',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/schemas/{id}',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdgetSelfServiceBrowserLoginRequest"></a>

### Get the request context of browser-based login user flows

```
GET /self-service/browser/flows/requests/login?request=string HTTP/1.1
Accept: application/json

```

This endpoint returns a login request's context with, for example, error details and
other information.

When accessing this endpoint through ORY Kratos' Public API, ensure that cookies are set as they are required for CSRF to work. To prevent
token scanning attacks, the public endpoint does not return 404 status codes.

More information can be found at [ORY Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).

<a id="get-the-request-context-of-browser-based-login-user-flows-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|request|query|string|true|Request is the Login Request ID|

##### Detailed descriptions

**request**: Request is the Login Request ID

The value for this parameter comes from `request` URL Query parameter sent to your
application (e.g. `/login?request=abcde`).

#### Responses

<a id="get-the-request-context-of-browser-based-login-user-flows-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|loginRequest|[loginRequest](#schemaloginrequest)|
|403|[Forbidden](https://tools.ietf.org/html/rfc7231#section-6.5.3)|genericError|[genericError](#schemagenericerror)|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|410|[Gone](https://tools.ietf.org/html/rfc7231#section-6.5.9)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "active": "string",
  "expires_at": "2019-08-24T14:15:22Z",
  "forced": true,
  "id": "string",
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "methods": {
    "property1": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string",
        "providers": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ]
      },
      "method": "string"
    },
    "property2": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string",
        "providers": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ]
      },
      "method": "string"
    }
  },
  "request_url": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/requests/login?request=string \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/requests/login", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/requests/login?request=string', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/requests/login?request=string");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/requests/login',
  params={
    'request': 'string'},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/requests/login',
  params: {
    'request' => 'string'}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdgetSelfServiceBrowserRecoveryRequest"></a>

### Get the request context of browser-based recovery flows

```
GET /self-service/browser/flows/requests/recovery?request=string HTTP/1.1
Accept: application/json

```

When accessing this endpoint through ORY Kratos' Public API, ensure that cookies are set as they are required
for checking the auth session. To prevent scanning attacks, the public endpoint does not return 404 status codes
but instead 403 or 500.

More information can be found at [ORY Kratos Account Recovery Documentation](../self-service/flows/account-recovery.mdx).

<a id="get-the-request-context-of-browser-based-recovery-flows-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|request|query|string|true|Request is the Login Request ID|

##### Detailed descriptions

**request**: Request is the Login Request ID

The value for this parameter comes from `request` URL Query parameter sent to your
application (e.g. `/recover?request=abcde`).

#### Responses

<a id="get-the-request-context-of-browser-based-recovery-flows-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|recoveryRequest|[recoveryRequest](#schemarecoveryrequest)|
|403|[Forbidden](https://tools.ietf.org/html/rfc7231#section-6.5.3)|genericError|[genericError](#schemagenericerror)|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|410|[Gone](https://tools.ietf.org/html/rfc7231#section-6.5.9)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "active": "string",
  "expires_at": "2019-08-24T14:15:22Z",
  "id": "string",
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "methods": {
    "property1": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string"
      },
      "method": "string"
    },
    "property2": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string"
      },
      "method": "string"
    }
  },
  "request_url": "string",
  "state": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/requests/recovery?request=string \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/requests/recovery", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/requests/recovery?request=string', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/requests/recovery?request=string");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/requests/recovery',
  params={
    'request': 'string'},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/requests/recovery',
  params: {
    'request' => 'string'}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdgetSelfServiceBrowserRegistrationRequest"></a>

### Get the request context of browser-based registration user flows

```
GET /self-service/browser/flows/requests/registration?request=string HTTP/1.1
Accept: application/json

```

This endpoint returns a registration request's context with, for example, error details and
other information.

When accessing this endpoint through ORY Kratos' Public API, ensure that cookies are set as they are required for CSRF to work. To prevent
token scanning attacks, the public endpoint does not return 404 status codes.

More information can be found at [ORY Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).

<a id="get-the-request-context-of-browser-based-registration-user-flows-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|request|query|string|true|Request is the Registration Request ID|

##### Detailed descriptions

**request**: Request is the Registration Request ID

The value for this parameter comes from `request` URL Query parameter sent to your
application (e.g. `/registration?request=abcde`).

#### Responses

<a id="get-the-request-context-of-browser-based-registration-user-flows-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|registrationRequest|[registrationRequest](#schemaregistrationrequest)|
|403|[Forbidden](https://tools.ietf.org/html/rfc7231#section-6.5.3)|genericError|[genericError](#schemagenericerror)|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|410|[Gone](https://tools.ietf.org/html/rfc7231#section-6.5.9)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "active": "string",
  "expires_at": "2019-08-24T14:15:22Z",
  "id": "string",
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "methods": {
    "property1": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string",
        "providers": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ]
      },
      "method": "string"
    },
    "property2": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string",
        "providers": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ]
      },
      "method": "string"
    }
  },
  "request_url": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/requests/registration?request=string \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/requests/registration", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/requests/registration?request=string', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/requests/registration?request=string");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/requests/registration',
  params={
    'request': 'string'},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/requests/registration',
  params: {
    'request' => 'string'}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdgetSelfServiceBrowserSettingsRequest"></a>

### Get the request context of browser-based settings flows

```
GET /self-service/browser/flows/requests/settings?request=string HTTP/1.1
Accept: application/json

```

When accessing this endpoint through ORY Kratos' Public API, ensure that cookies are set as they are required
for checking the auth session. To prevent scanning attacks, the public endpoint does not return 404 status codes
but instead 403 or 500.

More information can be found at [ORY Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).

<a id="get-the-request-context-of-browser-based-settings-flows-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|request|query|string|true|Request is the Login Request ID|

##### Detailed descriptions

**request**: Request is the Login Request ID

The value for this parameter comes from `request` URL Query parameter sent to your
application (e.g. `/settingss?request=abcde`).

#### Responses

<a id="get-the-request-context-of-browser-based-settings-flows-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|settingsRequest|[settingsRequest](#schemasettingsrequest)|
|403|[Forbidden](https://tools.ietf.org/html/rfc7231#section-6.5.3)|genericError|[genericError](#schemagenericerror)|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|410|[Gone](https://tools.ietf.org/html/rfc7231#section-6.5.9)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "active": "string",
  "expires_at": "2019-08-24T14:15:22Z",
  "id": "string",
  "identity": {
    "id": "string",
    "recovery_addresses": [
      {
        "id": "string",
        "value": "string",
        "via": "string"
      }
    ],
    "schema_id": "string",
    "schema_url": "string",
    "traits": {},
    "verifiable_addresses": [
      {
        "expires_at": "2019-08-24T14:15:22Z",
        "id": "string",
        "value": "string",
        "verified": true,
        "verified_at": "2019-08-24T14:15:22Z",
        "via": "string"
      }
    ]
  },
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "methods": {
    "property1": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string"
      },
      "method": "string"
    },
    "property2": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string"
      },
      "method": "string"
    }
  },
  "request_url": "string",
  "state": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/requests/settings?request=string \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/requests/settings", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/requests/settings?request=string', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/requests/settings?request=string");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/requests/settings',
  params={
    'request': 'string'},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/requests/settings',
  params: {
    'request' => 'string'}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdgetSelfServiceVerificationRequest"></a>

### Get the request context of browser-based verification flows

```
GET /self-service/browser/flows/requests/verification?request=string HTTP/1.1
Accept: application/json

```

When accessing this endpoint through ORY Kratos' Public API, ensure that cookies are set as they are required
for checking the auth session. To prevent scanning attacks, the public endpoint does not return 404 status codes
but instead 403 or 500.

More information can be found at [ORY Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/selfservice/flows/verify-email-account-activation).

<a id="get-the-request-context-of-browser-based-verification-flows-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|request|query|string|true|Request is the Request ID|

##### Detailed descriptions

**request**: Request is the Request ID

The value for this parameter comes from `request` URL Query parameter sent to your
application (e.g. `/verify?request=abcde`).

#### Responses

<a id="get-the-request-context-of-browser-based-verification-flows-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|verificationRequest|[verificationRequest](#schemaverificationrequest)|
|403|[Forbidden](https://tools.ietf.org/html/rfc7231#section-6.5.3)|genericError|[genericError](#schemagenericerror)|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "expires_at": "2019-08-24T14:15:22Z",
  "form": {
    "action": "string",
    "fields": [
      {
        "disabled": true,
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "name": "string",
        "pattern": "string",
        "required": true,
        "type": "string",
        "value": {}
      }
    ],
    "messages": [
      {
        "context": {},
        "id": 0,
        "text": "string",
        "type": "string"
      }
    ],
    "method": "string"
  },
  "id": "string",
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "request_url": "string",
  "success": true,
  "via": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/requests/verification?request=string \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/requests/verification", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/requests/verification?request=string', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/requests/verification?request=string");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/requests/verification',
  params={
    'request': 'string'},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/requests/verification',
  params: {
    'request' => 'string'}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdgetSelfServiceError"></a>

### Get user-facing self-service errors

```
GET /self-service/errors HTTP/1.1
Accept: application/json

```

This endpoint returns the error associated with a user-facing self service errors.

When accessing this endpoint through ORY Kratos' Public API, ensure that cookies are set as they are required for CSRF to work. To prevent
token scanning attacks, the public endpoint does not return 404 status codes.

More information can be found at [ORY Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).

<a id="get-user-facing-self-service-errors-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|error|query|string|false|none|

#### Responses

<a id="get-user-facing-self-service-errors-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|User-facing error response|[errorContainer](#schemaerrorcontainer)|
|403|[Forbidden](https://tools.ietf.org/html/rfc7231#section-6.5.3)|genericError|[genericError](#schemagenericerror)|
|404|[Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "errors": {},
  "id": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/errors \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/errors", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/errors', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/errors");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/errors',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/errors',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="ory-kratos-public-endpoints"></a>

## Public Endpoints

<a id="opIdinitializeSelfServiceBrowserLoginFlow"></a>

### Initialize browser-based login user flow

```
GET /self-service/browser/flows/login HTTP/1.1
Accept: application/json

```

This endpoint initializes a browser-based user login flow. Once initialized, the browser will be redirected to
`selfservice.flows.login.ui_url` with the request ID set as a query parameter. If a valid user session exists already, the browser will be
redirected to `urls.default_redirect_url`.

> This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...).

More information can be found at [ORY Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).

<a id="initialize-browser-based-login-user-flow-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|refresh|query|boolean|false|Refresh a login session|

##### Detailed descriptions

**refresh**: Refresh a login session

If set to true, this will refresh an existing login session by
asking the user to sign in again. This will reset the
authenticated_at time of the session.

#### Responses

<a id="initialize-browser-based-login-user-flow-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/login \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/login", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/login', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/login");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/login',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/login',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdinitializeSelfServiceBrowserLogoutFlow"></a>

### Initialize Browser-Based Logout User Flow

```
GET /self-service/browser/flows/logout HTTP/1.1
Accept: application/json

```

This endpoint initializes a logout flow.

> This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...).

On successful logout, the browser will be redirected (HTTP 302 Found) to `urls.default_return_to`.

More information can be found at [ORY Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).

#### Responses

<a id="initialize-browser-based-logout-user-flow-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/logout \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/logout", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/logout', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/logout");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/logout',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/logout',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdinitializeSelfServiceRecoveryFlow"></a>

### Initialize browser-based account recovery flow

```
GET /self-service/browser/flows/recovery HTTP/1.1
Accept: application/json

```

This endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to
`selfservice.flows.recovery.ui_url` with the request ID set as a query parameter. If a valid user session exists, the request
is aborted.

> This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...).

More information can be found at [ORY Kratos Account Recovery Documentation](../self-service/flows/account-recovery.mdx).

#### Responses

<a id="initialize-browser-based-account-recovery-flow-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/recovery \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/recovery", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/recovery', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/recovery");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/recovery',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/recovery',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdcompleteSelfServiceBrowserRecoveryLinkStrategyFlow"></a>

### Complete the browser-based recovery flow using a recovery link

```
POST /self-service/browser/flows/recovery/link HTTP/1.1
Accept: application/json

```

> This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...) and HTML Forms.

More information can be found at [ORY Kratos Account Recovery Documentation](../self-service/flows/account-recovery.mdx).

#### Responses

<a id="complete-the-browser-based-recovery-flow-using-a-recovery-link-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X POST /self-service/browser/flows/recovery/link \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("POST", "/self-service/browser/flows/recovery/link", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/recovery/link', {
  method: 'POST',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/recovery/link");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("POST");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.post(
  '/self-service/browser/flows/recovery/link',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.post '/self-service/browser/flows/recovery/link',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdinitializeSelfServiceBrowserRegistrationFlow"></a>

### Initialize browser-based registration user flow

```
GET /self-service/browser/flows/registration HTTP/1.1
Accept: application/json

```

This endpoint initializes a browser-based user registration flow. Once initialized, the browser will be redirected to
`selfservice.flows.registration.ui_url` with the request ID set as a query parameter. If a valid user session exists already, the browser will be
redirected to `urls.default_redirect_url`.

> This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...).

More information can be found at [ORY Kratos User Login and User Registration Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-login-user-registration).

#### Responses

<a id="initialize-browser-based-registration-user-flow-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/registration \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/registration", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/registration', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/registration");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/registration',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/registration',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdcompleteSelfServiceBrowserSettingsOIDCSettingsFlow"></a>

### Complete the browser-based settings flow for the OpenID Connect strategy

```
POST /self-service/browser/flows/registration/strategies/oidc/settings/connections HTTP/1.1
Accept: application/json

```

This endpoint completes a browser-based settings flow. This is usually achieved by POSTing data to this
endpoint.

> This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...) and HTML Forms.

More information can be found at [ORY Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).

#### Responses

<a id="complete-the-browser-based-settings-flow-for-the-openid-connect-strategy-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X POST /self-service/browser/flows/registration/strategies/oidc/settings/connections \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("POST", "/self-service/browser/flows/registration/strategies/oidc/settings/connections", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/registration/strategies/oidc/settings/connections', {
  method: 'POST',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/registration/strategies/oidc/settings/connections");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("POST");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.post(
  '/self-service/browser/flows/registration/strategies/oidc/settings/connections',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.post '/self-service/browser/flows/registration/strategies/oidc/settings/connections',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdinitializeSelfServiceSettingsFlow"></a>

### Initialize browser-based settings flow

```
GET /self-service/browser/flows/settings HTTP/1.1
Accept: application/json

```

This endpoint initializes a browser-based settings flow. Once initialized, the browser will be redirected to
`selfservice.flows.settings.ui_url` with the request ID set as a query parameter. If no valid user session exists, a login
flow will be initialized.

> This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...).

More information can be found at [ORY Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).

#### Responses

<a id="initialize-browser-based-settings-flow-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/settings \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/settings", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/settings', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/settings");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/settings',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/settings',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdcompleteSelfServiceBrowserSettingsPasswordStrategyFlow"></a>

### Complete the browser-based settings flow for the password strategy

```
POST /self-service/browser/flows/settings/strategies/password HTTP/1.1
Accept: application/json

```

This endpoint completes a browser-based settings flow. This is usually achieved by POSTing data to this
endpoint.

> This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...) and HTML Forms.

More information can be found at [ORY Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).

#### Responses

<a id="complete-the-browser-based-settings-flow-for-the-password-strategy-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X POST /self-service/browser/flows/settings/strategies/password \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("POST", "/self-service/browser/flows/settings/strategies/password", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/settings/strategies/password', {
  method: 'POST',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/settings/strategies/password");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("POST");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.post(
  '/self-service/browser/flows/settings/strategies/password',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.post '/self-service/browser/flows/settings/strategies/password',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdcompleteSelfServiceBrowserSettingsProfileStrategyFlow"></a>

### Complete the browser-based settings flow for profile data

```
POST /self-service/browser/flows/settings/strategies/profile?request=string HTTP/1.1
Content-Type: application/json
Accept: application/json

```

This endpoint completes a browser-based settings flow. This is usually achieved by POSTing data to this
endpoint.

If the provided profile data is valid against the Identity's Traits JSON Schema, the data will be updated and
the browser redirected to `url.settings_ui` for further steps.

> This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...) and HTML Forms.

More information can be found at [ORY Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).

#### Request body

```json
{
  "request_id": "string",
  "traits": {}
}
```

```yaml
request_id: string
traits: {}

```

<a id="complete-the-browser-based-settings-flow-for-profile-data-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|request|query|string|true|Request is the request ID.|
|body|body|[completeSelfServiceBrowserSettingsStrategyProfileFlowPayload](#schemacompleteselfservicebrowsersettingsstrategyprofileflowpayload)|true|none|

#### Responses

<a id="complete-the-browser-based-settings-flow-for-profile-data-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X POST /self-service/browser/flows/settings/strategies/profile?request=string \
  -H 'Content-Type: application/json' \  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Content-Type": []string{"application/json"},
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("POST", "/self-service/browser/flows/settings/strategies/profile", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');
const input = '{
  "request_id": "string",
  "traits": {}
}';
const headers = {
  'Content-Type': 'application/json',  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/settings/strategies/profile?request=string', {
  method: 'POST',
  body: input,
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/settings/strategies/profile?request=string");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("POST");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json'
}

r = requests.post(
  '/self-service/browser/flows/settings/strategies/profile',
  params={
    'request': 'string'},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Content-Type' => 'application/json',
  'Accept' => 'application/json'
}

result = RestClient.post '/self-service/browser/flows/settings/strategies/profile',
  params: {
    'request' => 'string'}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdinitializeSelfServiceBrowserVerificationFlow"></a>

### Initialize browser-based verification flow

```
GET /self-service/browser/flows/verification/init/{via} HTTP/1.1
Accept: application/json

```

This endpoint initializes a browser-based verification flow. Once initialized, the browser will be redirected to
`selfservice.flows.settings.ui_url` with the request ID set as a query parameter. If no valid user session exists, a login
flow will be initialized.

> This endpoint is NOT INTENDED for API clients and only works
with browsers (Chrome, Firefox, ...).

More information can be found at [ORY Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/selfservice/flows/verify-email-account-activation).

<a id="initialize-browser-based-verification-flow-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|via|path|string|true|What to verify|

##### Detailed descriptions

**via**: What to verify

Currently only "email" is supported.

#### Responses

<a id="initialize-browser-based-verification-flow-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/verification/init/{via} \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/verification/init/{via}", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/verification/init/{via}', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/verification/init/{via}");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/verification/init/{via}',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/verification/init/{via}',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdselfServiceBrowserVerify"></a>

### Complete the browser-based verification flows

```
GET /self-service/browser/flows/verification/{via}/confirm/{code} HTTP/1.1
Accept: application/json

```

This endpoint completes a browser-based verification flow.

> This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...) and HTML Forms.

More information can be found at [ORY Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/selfservice/flows/verify-email-account-activation).

<a id="complete-the-browser-based-verification-flows-parameters"></a>

#### Parameters

|Parameter|In|Type|Required|Description|
|---|---|---|---|---|
|code|path|string|true|none|
|via|path|string|true|What to verify|

##### Detailed descriptions

**via**: What to verify

Currently only "email" is supported.

#### Responses

<a id="complete-the-browser-based-verification-flows-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|302|[Found](https://tools.ietf.org/html/rfc7231#section-6.4.3)|Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
typically 201.|None|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 500 response

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /self-service/browser/flows/verification/{via}/confirm/{code} \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/self-service/browser/flows/verification/{via}/confirm/{code}", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/self-service/browser/flows/verification/{via}/confirm/{code}', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/self-service/browser/flows/verification/{via}/confirm/{code}");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/self-service/browser/flows/verification/{via}/confirm/{code}',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/self-service/browser/flows/verification/{via}/confirm/{code}',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="opIdwhoami"></a>

### Check who the current HTTP session belongs to

```
GET /sessions/whoami HTTP/1.1
Accept: application/json

```

Uses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated.
Returns a session object in the body or 401 if the credentials are invalid or no credentials were sent.
Additionally when the request it successful it adds the user ID to the 'X-Kratos-Authenticated-Identity-Id' header in the response.

This endpoint is useful for reverse proxies and API Gateways.

#### Responses

<a id="check-who-the-current-http-session-belongs-to-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|session|[session](#schemasession)|
|403|[Forbidden](https://tools.ietf.org/html/rfc7231#section-6.5.3)|genericError|[genericError](#schemagenericerror)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|genericError|[genericError](#schemagenericerror)|

##### Examples

###### 200 response

```json
{
  "authenticated_at": "2019-08-24T14:15:22Z",
  "expires_at": "2019-08-24T14:15:22Z",
  "identity": {
    "id": "string",
    "recovery_addresses": [
      {
        "id": "string",
        "value": "string",
        "via": "string"
      }
    ],
    "schema_id": "string",
    "schema_url": "string",
    "traits": {},
    "verifiable_addresses": [
      {
        "expires_at": "2019-08-24T14:15:22Z",
        "id": "string",
        "value": "string",
        "verified": true,
        "verified_at": "2019-08-24T14:15:22Z",
        "via": "string"
      }
    ]
  },
  "issued_at": "2019-08-24T14:15:22Z",
  "sid": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /sessions/whoami \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/sessions/whoami", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/sessions/whoami', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/sessions/whoami");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/sessions/whoami',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/sessions/whoami',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

<a id="ory-kratos-version"></a>

## version

<a id="opIdgetVersion"></a>

### Get service version

```
GET /version HTTP/1.1
Accept: application/json

```

This endpoint returns the service version typically notated using semantic versioning.

If the service supports TLS Edge Termination, this endpoint does not require the
`X-Forwarded-Proto` header to be set.

Be aware that if you are running multiple nodes of this service, the health status will never
refer to the cluster state, only to a single instance.

#### Responses

<a id="get-service-version-responses"></a>

##### Overview

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|version|[version](#schemaversion)|

##### Examples

###### 200 response

```json
{
  "version": "string"
}
```

<aside class="success">
This operation does not require authentication
</aside>

#### Code samples

<Tabs groupId="code-samples" defaultValue="shell"
  values={[{label: 'Shell', value: 'shell'}, {label: 'Go', value: 'go'}, {label: 'Node', value: 'node'},
    {label: 'Java', value: 'java'}, {label: 'Python', value: 'python'}, {label: 'Ruby', value: 'ruby'}]}>
<TabItem value="shell">

```shell
curl -X GET /version \
  -H 'Accept: application/json'
```

</TabItem>
<TabItem value="go">

```go
package main

import (
    "bytes"
    "net/http"
)

func main() {
    headers := map[string][]string{
        "Accept": []string{"application/json"},
    }

    var body []byte
    // body = ...

    req, err := http.NewRequest("GET", "/version", bytes.NewBuffer(body))
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}
```

</TabItem>
<TabItem value="node">

```javascript
const fetch = require('node-fetch');

const headers = {
  'Accept': 'application/json'
}

fetch('/version', {
  method: 'GET',
  headers
})
.then(r => r.json())
.then((body) => {
    console.log(body)
})
```

</TabItem>
<TabItem value="java">

```java
// This sample needs improvement.
URL obj = new URL("/version");

HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");

int responseCode = con.getResponseCode();

BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream())
);

String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();

System.out.println(response.toString());
```

</TabItem>
<TabItem value="python">

```python
import requests

headers = {
  'Accept': 'application/json'
}

r = requests.get(
  '/version',
  params={},
  headers = headers)

print r.json()
```

</TabItem>
<TabItem value="ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json'
}

result = RestClient.get '/version',
  params: {}, headers: headers

p JSON.parse(result)
```

</TabItem>
</Tabs>

## Schemas

<a id="tocScredentialstype">CredentialsType</a>
#### CredentialsType

<a id="schemacredentialstype"></a>

```json
"string"

```

*CredentialsType  represents several different credential types, like password credentials, passwordless credentials,*

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|CredentialsType  represents several different credential types, like password credentials, passwordless credentials,|string|false|none|and so on.|

<a id="tocSid">ID</a>
#### ID

<a id="schemaid"></a>

```json
0

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|integer(int64)|false|none|none|

<a id="tocSidentity">Identity</a>
#### Identity

<a id="schemaidentity"></a>

```json
{
  "id": "string",
  "recovery_addresses": [
    {
      "id": "string",
      "value": "string",
      "via": "string"
    }
  ],
  "schema_id": "string",
  "schema_url": "string",
  "traits": {},
  "verifiable_addresses": [
    {
      "expires_at": "2019-08-24T14:15:22Z",
      "id": "string",
      "value": "string",
      "verified": true,
      "verified_at": "2019-08-24T14:15:22Z",
      "via": "string"
    }
  ]
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|[UUID](#schemauuid)|true|none|none|
|recovery_addresses|[[RecoveryAddress](#schemarecoveryaddress)]|false|none|RecoveryAddresses contains all the addresses that can be used to recover an identity.|
|schema_id|string|true|none|SchemaID is the ID of the JSON Schema to be used for validating the identity's traits.|
|schema_url|string|false|none|SchemaURL is the URL of the endpoint where the identity's traits schema can be fetched from.  format: url|
|traits|[Traits](#schematraits)|true|none|none|
|verifiable_addresses|[[VerifiableAddress](#schemaverifiableaddress)]|false|none|VerifiableAddresses contains all the addresses that can be verified by the user.|

<a id="tocSmessage">Message</a>
#### Message

<a id="schemamessage"></a>

```json
{
  "context": {},
  "id": 0,
  "text": "string",
  "type": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|context|object|false|none|none|
|id|[ID](#schemaid)|false|none|none|
|text|string|false|none|none|
|type|[Type](#schematype)|false|none|none|

<a id="tocSmessages">Messages</a>
#### Messages

<a id="schemamessages"></a>

```json
[
  {
    "context": {},
    "id": 0,
    "text": "string",
    "type": "string"
  }
]

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|[[Message](#schemamessage)]|false|none|none|

<a id="tocSprovidercredentialsconfig">ProviderCredentialsConfig</a>
#### ProviderCredentialsConfig

<a id="schemaprovidercredentialsconfig"></a>

```json
{
  "provider": "string",
  "subject": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|provider|string|false|none|none|
|subject|string|false|none|none|

<a id="tocSrecoveryaddress">RecoveryAddress</a>
#### RecoveryAddress

<a id="schemarecoveryaddress"></a>

```json
{
  "id": "string",
  "value": "string",
  "via": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|[UUID](#schemauuid)|true|none|none|
|value|string|true|none|none|
|via|[RecoveryAddressType](#schemarecoveryaddresstype)|true|none|none|

<a id="tocSrecoveryaddresstype">RecoveryAddressType</a>
#### RecoveryAddressType

<a id="schemarecoveryaddresstype"></a>

```json
"string"

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|none|

<a id="tocSrequestmethodconfig">RequestMethodConfig</a>
#### RequestMethodConfig

<a id="schemarequestmethodconfig"></a>

```json
{
  "action": "string",
  "fields": [
    {
      "disabled": true,
      "messages": [
        {
          "context": {},
          "id": 0,
          "text": "string",
          "type": "string"
        }
      ],
      "name": "string",
      "pattern": "string",
      "required": true,
      "type": "string",
      "value": {}
    }
  ],
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "method": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|action|string|true|none|Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`.|
|fields|[formFields](#schemaformfields)|true|none|Fields contains multiple fields|
|messages|[Messages](#schemamessages)|false|none|none|
|method|string|true|none|Method is the form method (e.g. POST)|

<a id="tocSstate">State</a>
#### State

<a id="schemastate"></a>

```json
"string"

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|none|

<a id="tocStraits">Traits</a>
#### Traits

<a id="schematraits"></a>

```json
{}

```

#### Properties

*None*

<a id="tocStype">Type</a>
#### Type

<a id="schematype"></a>

```json
"string"

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|none|

<a id="tocSuuid">UUID</a>
#### UUID

<a id="schemauuid"></a>

```json
"string"

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string(uuid4)|false|none|none|

<a id="tocSverifiableaddress">VerifiableAddress</a>
#### VerifiableAddress

<a id="schemaverifiableaddress"></a>

```json
{
  "expires_at": "2019-08-24T14:15:22Z",
  "id": "string",
  "value": "string",
  "verified": true,
  "verified_at": "2019-08-24T14:15:22Z",
  "via": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|expires_at|string(date-time)|true|none|none|
|id|[UUID](#schemauuid)|true|none|none|
|value|string|true|none|none|
|verified|boolean|true|none|none|
|verified_at|string(date-time)|false|none|none|
|via|[VerifiableAddressType](#schemaverifiableaddresstype)|true|none|none|

<a id="tocSverifiableaddresstype">VerifiableAddressType</a>
#### VerifiableAddressType

<a id="schemaverifiableaddresstype"></a>

```json
"string"

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|none|

<a id="tocScompleteselfservicebrowsersettingsstrategyprofileflowpayload">completeSelfServiceBrowserSettingsStrategyProfileFlowPayload</a>
#### completeSelfServiceBrowserSettingsStrategyProfileFlowPayload

<a id="schemacompleteselfservicebrowsersettingsstrategyprofileflowpayload"></a>

```json
{
  "request_id": "string",
  "traits": {}
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|request_id|string|false|none|RequestID is request ID.  in: query|
|traits|object|true|none|Traits contains all of the identity's traits.  type: string format: binary|

<a id="tocSerrorcontainer">errorContainer</a>
#### errorContainer

<a id="schemaerrorcontainer"></a>

```json
{
  "errors": {},
  "id": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|errors|object|false|none|none|
|id|[UUID](#schemauuid)|false|none|none|

<a id="tocSform">form</a>
#### form

<a id="schemaform"></a>

```json
{
  "action": "string",
  "fields": [
    {
      "disabled": true,
      "messages": [
        {
          "context": {},
          "id": 0,
          "text": "string",
          "type": "string"
        }
      ],
      "name": "string",
      "pattern": "string",
      "required": true,
      "type": "string",
      "value": {}
    }
  ],
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "method": "string"
}

```

*HTMLForm represents a HTML Form. The container can work with both HTTP Form and JSON requests*

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|action|string|true|none|Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`.|
|fields|[formFields](#schemaformfields)|true|none|Fields contains multiple fields|
|messages|[Messages](#schemamessages)|false|none|none|
|method|string|true|none|Method is the form method (e.g. POST)|

<a id="tocSformfield">formField</a>
#### formField

<a id="schemaformfield"></a>

```json
{
  "disabled": true,
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "name": "string",
  "pattern": "string",
  "required": true,
  "type": "string",
  "value": {}
}

```

*Field represents a HTML Form Field*

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|disabled|boolean|false|none|Disabled is the equivalent of `<input {{if .Disabled}}disabled{{end}}">`|
|messages|[Messages](#schemamessages)|false|none|none|
|name|string|true|none|Name is the equivalent of `<input name="{{.Name}}">`|
|pattern|string|false|none|Pattern is the equivalent of `<input pattern="{{.Pattern}}">`|
|required|boolean|false|none|Required is the equivalent of `<input required="{{.Required}}">`|
|type|string|true|none|Type is the equivalent of `<input type="{{.Type}}">`|
|value|object|false|none|Value is the equivalent of `<input value="{{.Value}}">`|

<a id="tocSformfields">formFields</a>
#### formFields

<a id="schemaformfields"></a>

```json
[
  {
    "disabled": true,
    "messages": [
      {
        "context": {},
        "id": 0,
        "text": "string",
        "type": "string"
      }
    ],
    "name": "string",
    "pattern": "string",
    "required": true,
    "type": "string",
    "value": {}
  }
]

```

*Fields contains multiple fields*

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|[[formField](#schemaformfield)]|false|none|Fields contains multiple fields|

<a id="tocSgenericerror">genericError</a>
#### genericError

<a id="schemagenericerror"></a>

```json
{
  "error": {
    "code": 404,
    "debug": "The database adapter was unable to find the element",
    "details": {},
    "message": "string",
    "reason": "string",
    "request": "string",
    "status": "string"
  }
}

```

*Error response*

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|[genericErrorPayload](#schemagenericerrorpayload)|false|none|none|

<a id="tocSgenericerrorpayload">genericErrorPayload</a>
#### genericErrorPayload

<a id="schemagenericerrorpayload"></a>

```json
{
  "code": 404,
  "debug": "The database adapter was unable to find the element",
  "details": {},
  "message": "string",
  "reason": "string",
  "request": "string",
  "status": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|code|integer(int64)|false|none|Code represents the error status code (404, 403, 401, ...).|
|debug|string|false|none|Debug contains debug information. This is usually not available and has to be enabled.|
|details|object|false|none|none|
|message|string|false|none|none|
|reason|string|false|none|none|
|request|string|false|none|none|
|status|string|false|none|none|

<a id="tocShealthnotreadystatus">healthNotReadyStatus</a>
#### healthNotReadyStatus

<a id="schemahealthnotreadystatus"></a>

```json
{
  "errors": {
    "property1": "string",
    "property2": "string"
  }
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|errors|object|false|none|Errors contains a list of errors that caused the not ready status.|
|» **additionalProperties**|string|false|none|none|

<a id="tocShealthstatus">healthStatus</a>
#### healthStatus

<a id="schemahealthstatus"></a>

```json
{
  "status": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|status|string|false|none|Status always contains "ok".|

<a id="tocSloginrequest">loginRequest</a>
#### loginRequest

<a id="schemaloginrequest"></a>

```json
{
  "active": "string",
  "expires_at": "2019-08-24T14:15:22Z",
  "forced": true,
  "id": "string",
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "methods": {
    "property1": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string",
        "providers": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ]
      },
      "method": "string"
    },
    "property2": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string",
        "providers": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ]
      },
      "method": "string"
    }
  },
  "request_url": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|active|[CredentialsType](#schemacredentialstype)|false|none|and so on.|
|expires_at|string(date-time)|true|none|ExpiresAt is the time (UTC) when the request expires. If the user still wishes to log in, a new request has to be initiated.|
|forced|boolean|false|none|Forced stores whether this login request should enforce reauthentication.|
|id|[UUID](#schemauuid)|true|none|none|
|issued_at|string(date-time)|true|none|IssuedAt is the time (UTC) when the request occurred.|
|messages|[Messages](#schemamessages)|false|none|none|
|methods|object|true|none|Methods contains context for all enabled login methods. If a login request has been processed, but for example the password is incorrect, this will contain error messages.|
|» **additionalProperties**|[loginRequestMethod](#schemaloginrequestmethod)|false|none|none|
|request_url|string|true|none|RequestURL is the initial URL that was requested from ORY Kratos. It can be used to forward information contained in the URL's path or query for example.|

<a id="tocSloginrequestmethod">loginRequestMethod</a>
#### loginRequestMethod

<a id="schemaloginrequestmethod"></a>

```json
{
  "config": {
    "action": "string",
    "fields": [
      {
        "disabled": true,
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "name": "string",
        "pattern": "string",
        "required": true,
        "type": "string",
        "value": {}
      }
    ],
    "messages": [
      {
        "context": {},
        "id": 0,
        "text": "string",
        "type": "string"
      }
    ],
    "method": "string",
    "providers": [
      {
        "disabled": true,
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "name": "string",
        "pattern": "string",
        "required": true,
        "type": "string",
        "value": {}
      }
    ]
  },
  "method": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|[loginRequestMethodConfig](#schemaloginrequestmethodconfig)|true|none|none|
|method|[CredentialsType](#schemacredentialstype)|true|none|and so on.|

<a id="tocSloginrequestmethodconfig">loginRequestMethodConfig</a>
#### loginRequestMethodConfig

<a id="schemaloginrequestmethodconfig"></a>

```json
{
  "action": "string",
  "fields": [
    {
      "disabled": true,
      "messages": [
        {
          "context": {},
          "id": 0,
          "text": "string",
          "type": "string"
        }
      ],
      "name": "string",
      "pattern": "string",
      "required": true,
      "type": "string",
      "value": {}
    }
  ],
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "method": "string",
  "providers": [
    {
      "disabled": true,
      "messages": [
        {
          "context": {},
          "id": 0,
          "text": "string",
          "type": "string"
        }
      ],
      "name": "string",
      "pattern": "string",
      "required": true,
      "type": "string",
      "value": {}
    }
  ]
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|action|string|true|none|Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`.|
|fields|[formFields](#schemaformfields)|true|none|Fields contains multiple fields|
|messages|[Messages](#schemamessages)|false|none|none|
|method|string|true|none|Method is the form method (e.g. POST)|
|providers|[[formField](#schemaformfield)]|false|none|Providers is set for the "oidc" request method.|

<a id="tocSrecoveryrequest">recoveryRequest</a>
#### recoveryRequest

<a id="schemarecoveryrequest"></a>

```json
{
  "active": "string",
  "expires_at": "2019-08-24T14:15:22Z",
  "id": "string",
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "methods": {
    "property1": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string"
      },
      "method": "string"
    },
    "property2": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string"
      },
      "method": "string"
    }
  },
  "request_url": "string",
  "state": "string"
}

```

*Request presents a recovery request*

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|active|string|false|none|Active, if set, contains the registration method that is being used. It is initially not set.|
|expires_at|string(date-time)|true|none|ExpiresAt is the time (UTC) when the request expires. If the user still wishes to update the setting, a new request has to be initiated.|
|id|[UUID](#schemauuid)|true|none|none|
|issued_at|string(date-time)|true|none|IssuedAt is the time (UTC) when the request occurred.|
|messages|[Messages](#schemamessages)|false|none|none|
|methods|object|true|none|Methods contains context for all account recovery methods. If a registration request has been processed, but for example the password is incorrect, this will contain error messages.|
|» **additionalProperties**|[recoveryRequestMethod](#schemarecoveryrequestmethod)|false|none|none|
|request_url|string|true|none|RequestURL is the initial URL that was requested from ORY Kratos. It can be used to forward information contained in the URL's path or query for example.|
|state|[State](#schemastate)|true|none|none|

<a id="tocSrecoveryrequestmethod">recoveryRequestMethod</a>
#### recoveryRequestMethod

<a id="schemarecoveryrequestmethod"></a>

```json
{
  "config": {
    "action": "string",
    "fields": [
      {
        "disabled": true,
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "name": "string",
        "pattern": "string",
        "required": true,
        "type": "string",
        "value": {}
      }
    ],
    "messages": [
      {
        "context": {},
        "id": 0,
        "text": "string",
        "type": "string"
      }
    ],
    "method": "string"
  },
  "method": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|[RequestMethodConfig](#schemarequestmethodconfig)|false|none|none|
|method|string|false|none|Method contains the request credentials type.|

<a id="tocSregistrationrequest">registrationRequest</a>
#### registrationRequest

<a id="schemaregistrationrequest"></a>

```json
{
  "active": "string",
  "expires_at": "2019-08-24T14:15:22Z",
  "id": "string",
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "methods": {
    "property1": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string",
        "providers": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ]
      },
      "method": "string"
    },
    "property2": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string",
        "providers": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ]
      },
      "method": "string"
    }
  },
  "request_url": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|active|[CredentialsType](#schemacredentialstype)|false|none|and so on.|
|expires_at|string(date-time)|true|none|ExpiresAt is the time (UTC) when the request expires. If the user still wishes to log in, a new request has to be initiated.|
|id|[UUID](#schemauuid)|true|none|none|
|issued_at|string(date-time)|true|none|IssuedAt is the time (UTC) when the request occurred.|
|messages|[Messages](#schemamessages)|false|none|none|
|methods|object|true|none|Methods contains context for all enabled registration methods. If a registration request has been processed, but for example the password is incorrect, this will contain error messages.|
|» **additionalProperties**|[registrationRequestMethod](#schemaregistrationrequestmethod)|false|none|none|
|request_url|string|true|none|RequestURL is the initial URL that was requested from ORY Kratos. It can be used to forward information contained in the URL's path or query for example.|

<a id="tocSregistrationrequestmethod">registrationRequestMethod</a>
#### registrationRequestMethod

<a id="schemaregistrationrequestmethod"></a>

```json
{
  "config": {
    "action": "string",
    "fields": [
      {
        "disabled": true,
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "name": "string",
        "pattern": "string",
        "required": true,
        "type": "string",
        "value": {}
      }
    ],
    "messages": [
      {
        "context": {},
        "id": 0,
        "text": "string",
        "type": "string"
      }
    ],
    "method": "string",
    "providers": [
      {
        "disabled": true,
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "name": "string",
        "pattern": "string",
        "required": true,
        "type": "string",
        "value": {}
      }
    ]
  },
  "method": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|[registrationRequestMethodConfig](#schemaregistrationrequestmethodconfig)|false|none|none|
|method|[CredentialsType](#schemacredentialstype)|false|none|and so on.|

<a id="tocSregistrationrequestmethodconfig">registrationRequestMethodConfig</a>
#### registrationRequestMethodConfig

<a id="schemaregistrationrequestmethodconfig"></a>

```json
{
  "action": "string",
  "fields": [
    {
      "disabled": true,
      "messages": [
        {
          "context": {},
          "id": 0,
          "text": "string",
          "type": "string"
        }
      ],
      "name": "string",
      "pattern": "string",
      "required": true,
      "type": "string",
      "value": {}
    }
  ],
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "method": "string",
  "providers": [
    {
      "disabled": true,
      "messages": [
        {
          "context": {},
          "id": 0,
          "text": "string",
          "type": "string"
        }
      ],
      "name": "string",
      "pattern": "string",
      "required": true,
      "type": "string",
      "value": {}
    }
  ]
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|action|string|true|none|Action should be used as the form action URL `<form action="{{ .Action }}" method="post">`.|
|fields|[formFields](#schemaformfields)|true|none|Fields contains multiple fields|
|messages|[Messages](#schemamessages)|false|none|none|
|method|string|true|none|Method is the form method (e.g. POST)|
|providers|[[formField](#schemaformfield)]|false|none|Providers is set for the "oidc" request method.|

<a id="tocSsession">session</a>
#### session

<a id="schemasession"></a>

```json
{
  "authenticated_at": "2019-08-24T14:15:22Z",
  "expires_at": "2019-08-24T14:15:22Z",
  "identity": {
    "id": "string",
    "recovery_addresses": [
      {
        "id": "string",
        "value": "string",
        "via": "string"
      }
    ],
    "schema_id": "string",
    "schema_url": "string",
    "traits": {},
    "verifiable_addresses": [
      {
        "expires_at": "2019-08-24T14:15:22Z",
        "id": "string",
        "value": "string",
        "verified": true,
        "verified_at": "2019-08-24T14:15:22Z",
        "via": "string"
      }
    ]
  },
  "issued_at": "2019-08-24T14:15:22Z",
  "sid": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|authenticated_at|string(date-time)|true|none|none|
|expires_at|string(date-time)|true|none|none|
|identity|[Identity](#schemaidentity)|true|none|none|
|issued_at|string(date-time)|true|none|none|
|sid|[UUID](#schemauuid)|true|none|none|

<a id="tocSsettingsrequest">settingsRequest</a>
#### settingsRequest

<a id="schemasettingsrequest"></a>

```json
{
  "active": "string",
  "expires_at": "2019-08-24T14:15:22Z",
  "id": "string",
  "identity": {
    "id": "string",
    "recovery_addresses": [
      {
        "id": "string",
        "value": "string",
        "via": "string"
      }
    ],
    "schema_id": "string",
    "schema_url": "string",
    "traits": {},
    "verifiable_addresses": [
      {
        "expires_at": "2019-08-24T14:15:22Z",
        "id": "string",
        "value": "string",
        "verified": true,
        "verified_at": "2019-08-24T14:15:22Z",
        "via": "string"
      }
    ]
  },
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "methods": {
    "property1": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string"
      },
      "method": "string"
    },
    "property2": {
      "config": {
        "action": "string",
        "fields": [
          {
            "disabled": true,
            "messages": [
              {
                "context": {},
                "id": 0,
                "text": "string",
                "type": "string"
              }
            ],
            "name": "string",
            "pattern": "string",
            "required": true,
            "type": "string",
            "value": {}
          }
        ],
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "method": "string"
      },
      "method": "string"
    }
  },
  "request_url": "string",
  "state": "string"
}

```

*Request presents a settings request*

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|active|string|false|none|Active, if set, contains the registration method that is being used. It is initially not set.|
|expires_at|string(date-time)|true|none|ExpiresAt is the time (UTC) when the request expires. If the user still wishes to update the setting, a new request has to be initiated.|
|id|[UUID](#schemauuid)|true|none|none|
|identity|[Identity](#schemaidentity)|true|none|none|
|issued_at|string(date-time)|true|none|IssuedAt is the time (UTC) when the request occurred.|
|messages|[Messages](#schemamessages)|false|none|none|
|methods|object|true|none|Methods contains context for all enabled registration methods. If a registration request has been processed, but for example the password is incorrect, this will contain error messages.|
|» **additionalProperties**|[settingsRequestMethod](#schemasettingsrequestmethod)|false|none|none|
|request_url|string|true|none|RequestURL is the initial URL that was requested from ORY Kratos. It can be used to forward information contained in the URL's path or query for example.|
|state|[State](#schemastate)|true|none|none|

<a id="tocSsettingsrequestmethod">settingsRequestMethod</a>
#### settingsRequestMethod

<a id="schemasettingsrequestmethod"></a>

```json
{
  "config": {
    "action": "string",
    "fields": [
      {
        "disabled": true,
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "name": "string",
        "pattern": "string",
        "required": true,
        "type": "string",
        "value": {}
      }
    ],
    "messages": [
      {
        "context": {},
        "id": 0,
        "text": "string",
        "type": "string"
      }
    ],
    "method": "string"
  },
  "method": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|config|[RequestMethodConfig](#schemarequestmethodconfig)|false|none|none|
|method|string|false|none|Method contains the request credentials type.|

<a id="tocSverificationrequest">verificationRequest</a>
#### verificationRequest

<a id="schemaverificationrequest"></a>

```json
{
  "expires_at": "2019-08-24T14:15:22Z",
  "form": {
    "action": "string",
    "fields": [
      {
        "disabled": true,
        "messages": [
          {
            "context": {},
            "id": 0,
            "text": "string",
            "type": "string"
          }
        ],
        "name": "string",
        "pattern": "string",
        "required": true,
        "type": "string",
        "value": {}
      }
    ],
    "messages": [
      {
        "context": {},
        "id": 0,
        "text": "string",
        "type": "string"
      }
    ],
    "method": "string"
  },
  "id": "string",
  "issued_at": "2019-08-24T14:15:22Z",
  "messages": [
    {
      "context": {},
      "id": 0,
      "text": "string",
      "type": "string"
    }
  ],
  "request_url": "string",
  "success": true,
  "via": "string"
}

```

*Request presents a verification request*

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|expires_at|string(date-time)|false|none|ExpiresAt is the time (UTC) when the request expires. If the user still wishes to verify the address, a new request has to be initiated.|
|form|[form](#schemaform)|false|none|HTMLForm represents a HTML Form. The container can work with both HTTP Form and JSON requests|
|id|[UUID](#schemauuid)|false|none|none|
|issued_at|string(date-time)|false|none|IssuedAt is the time (UTC) when the request occurred.|
|messages|[Messages](#schemamessages)|false|none|none|
|request_url|string|false|none|RequestURL is the initial URL that was requested from ORY Kratos. It can be used to forward information contained in the URL's path or query for example.|
|success|boolean|false|none|Success, if true, implies that the request was completed successfully.|
|via|[VerifiableAddressType](#schemaverifiableaddresstype)|false|none|none|

<a id="tocSversion">version</a>
#### version

<a id="schemaversion"></a>

```json
{
  "version": "string"
}

```

#### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|version|string|false|none|Version is the service's version.|

